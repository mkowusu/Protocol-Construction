/* Test program for crypto_box utilities 

   Michael Owusu
   Camila Mateo

   created February 25, 2015
*/

#include <stdio.h>
#include <assert.h>
#include <crypto_box.h>
#include <time.h>
#include "client.h"  

int result; /* assertion for cryptobox */
int place; /* additional counter */
long long int counter; /* counter for assigning bytes to char arrays */

/* server generated keypair */
unsigned char server_pk[crypto_box_PUBLICKEYBYTES];
unsigned char server_sk[crypto_box_SECRETKEYBYTES];

/* server generated zero nonce */
unsigned char nonce_n0[crypto_box_NONCEBYTES];

/* store encrypted nonce N1 parsed from client */
unsigned char encryptedN1_from_client[crypto_box_NONCEBYTES];

/* nonce N2 generated by server */
unsigned char nonce_n2[crypto_box_NONCEBYTES];

/* public key parsed from client initial communication */
unsigned char pk_from_client[crypto_box_PUBLICKEYBYTES];

/* decrypted N1 from client with concatenated 0's */
unsigned char decrypted_n1_ZEROBYTES[crypto_box_NONCEBYTES + crypto_box_ZEROBYTES];

/* nonce N1 recieved from client */
unsigned char decrypted_n1[crypto_box_NONCEBYTES];

/* response to initial communication from client containing nonce N1, nonce N2, and a timestamp */
unsigned char server_message_1[SIZE_OF_TIME_T + (crypto_box_NONCEBYTES * 2) + crypto_box_ZEROBYTES];

/* encrypted response to initial communication from client */
unsigned char encrypted_server_message_1[SIZE_OF_TIME_T + (crypto_box_NONCEBYTES * 2) + crypto_box_ZEROBYTES];

/* decrypted question message recieved from server  */
unsigned char client_question_decrypted[crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES * 2) + INTERNAL_MESSAGE_LENGTH];

/* nonce N3 parsed from decrypted client question message */
unsigned char nonce_n3[crypto_box_NONCEBYTES];

/* unencrypted server answer message to be encrypted */
unsigned char server_answer[crypto_box_ZEROBYTES + crypto_box_NONCEBYTES + INTERNAL_MESSAGE_LENGTH];

/* encrypted server answer message to send to client */
unsigned char encrypted_server_answer[crypto_box_ZEROBYTES + crypto_box_NONCEBYTES + INTERNAL_MESSAGE_LENGTH];

/* union to store time value as time_t and an unsigned char of bytes */
union timestamp {
  time_t native; 
  unsigned char bytes[sizeof(time_t)];
};

/* variable to store generated server timestamp for verification */
union timestamp server_time;

/* variable to store timestamp from client */
union timestamp client_time;

/* union to store message sent and recieved between server and client */
union message {
  char* native;//[INTERNAL_MESSAGE_LENGTH]; 
  unsigned char bytes[INTERNAL_MESSAGE_LENGTH];
};

/* variable to store extracted client question */
union message question;  

/* variable to store server generated answer to client message */
union message answer;


/* begin server functions for interacting with system and client */


/* generate nonce N0 for initial communication */
void initialCommunicationRequirements() {

  (void) printf("\nServer generated nonce, N0:\n");
  for (counter = 0; counter < crypto_box_NONCEBYTES; counter++)
    nonce_n0[counter] = 0;

  /* print nonce N0 */
  display_bytes(nonce_n0, crypto_box_NONCEBYTES);

  /* construct keypairs for server. */
  result = crypto_box_keypair(server_pk, server_sk);
  assert(result == 0);

  /* print server's public and secret keys */
  (void) printf("Server Public Key:\n");
  display_bytes(server_pk, crypto_box_PUBLICKEYBYTES);

  (void) printf("Server Secret Key:\n");
  display_bytes(server_sk, crypto_box_SECRETKEYBYTES);
}

/* Function for initial response to communication with client by sending over nonce 
   N2, identifying client public key and sending a timestamp for verification.
*/
void serverInitialResponse() {

  /* server splits encrypted nonce and attached public key */
  (void) printf("Server splits message recieved from client into encrypted nonce and public key:\n\n");

  /* separates encrypted nonce 1 */
  for (counter = 0; counter < crypto_box_ZEROBYTES + crypto_box_NONCEBYTES; counter++)
    encryptedN1_from_client[counter] = initial_message[counter];

  place = 0; /* initialize placeholder */

  /* separates client public key */
  for (counter = counter; counter < crypto_box_ZEROBYTES + crypto_box_NONCEBYTES + crypto_box_PUBLICKEYBYTES; counter++)
    pk_from_client[place++] = initial_message[counter];

  /* print separated encrypted nonce 1 and client public key */
  (void) printf("Encrypted nonce N1 recieved from client:\n");
  display_bytes(encryptedN1_from_client,  crypto_box_ZEROBYTES + crypto_box_NONCEBYTES);

  (void) printf("Client public key identified by server:\n");
  display_bytes(pk_from_client, crypto_box_PUBLICKEYBYTES);

  /* decrypt the encrypted nonce 1 */
  result = crypto_box_open(decrypted_n1_ZEROBYTES, encryptedN1_from_client, crypto_box_ZEROBYTES + crypto_box_NONCEBYTES, nonce_n0, pk_from_client, server_sk);
  assert(result == 0);

  place = 0; /* reset placeholder */

  /* separate decrypted nonce 1 from concatenated ZEROBYTES */
  for (counter = crypto_box_ZEROBYTES; counter < crypto_box_ZEROBYTES + crypto_box_NONCEBYTES; counter++)
    decrypted_n1[place++] = decrypted_n1_ZEROBYTES[counter];

  (void) printf("Final nonce N1, decrypted and extracted by server:\n");
  display_bytes(decrypted_n1, crypto_box_NONCEBYTES);

  /* generate nonce 2 */
  (void) printf("Server generated nonce, N2:\n");
  randombytes(nonce_n2, crypto_box_NONCEBYTES);

  display_bytes(nonce_n2, crypto_box_NONCEBYTES);

  /* generate and print time stamp */
  server_time.native = time(NULL);

  (void) printf("Server time in seconds:\n");
  (void) printf("%ld\n\n", server_time.native);

  /* start generating response message to be sent to client */
  /* add zeroes to beginning of message to be encrypted */
  for (counter = 0; counter < crypto_box_ZEROBYTES; counter++)
    server_message_1[counter] = 0;

  place = 0;; /* reset placeholder */

  /* adding nonce 1 to message */
  for (counter = counter; counter < crypto_box_ZEROBYTES + crypto_box_NONCEBYTES; counter++)
    server_message_1[counter] = decrypted_n1[place++];

  place = 0; /* reset placeholder */

  /* adding nonce 2 to message */
  for (counter = counter; counter < crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES * 2); counter++)
    server_message_1[counter] = nonce_n2[place++];

  place = 0; /* reset placeholder */

  /* adding timestamp to message */
  for (counter = counter; counter < crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES * 2) + SIZE_OF_TIME_T; counter++)
    server_message_1[counter] = server_time.bytes[place++];

  /* print final message to be sent to client */
  (void) printf("Unencrypted message to be sent to client:\n");
  display_bytes(server_message_1, crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES * 2) + SIZE_OF_TIME_T );

  /* encrypt and print message */
  result = crypto_box(encrypted_server_message_1, server_message_1, crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES * 2) + SIZE_OF_TIME_T, decrypted_n1, pk_from_client, server_sk);
  assert(result == 0);

  (void) printf("Encrypted message to send to client:\n");
  display_bytes(encrypted_server_message_1, crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES * 2) + SIZE_OF_TIME_T );
}

/* Function to respond to question sent by client by sending over nonce 
   N3 and answer to question.
*/
void serverAnswerQuestion() {

  /* decrypt and print the message */
  result = crypto_box_open(client_question_decrypted, client_question_encrypted, crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES * 2) + INTERNAL_MESSAGE_LENGTH, nonce_n2, pk_from_client, server_sk);
  assert(result == 0);

  (void) printf("Server decrypted nonce N2, nonce N3, and question sent by client:\n");
  display_bytes(client_question_decrypted, crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES * 2) + INTERNAL_MESSAGE_LENGTH);

  place = 0; /* reset placeholder */

  /* separate and print decrypted nonce 3 from message received from client */
  for (counter = crypto_box_ZEROBYTES + crypto_box_NONCEBYTES; counter < crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES *2); counter++)
    nonce_n3[place++] = client_question_decrypted[counter];

  (void) printf("Nonce N3 extracted from message:\n");
  display_bytes(nonce_n3, crypto_box_NONCEBYTES);

  place = 0; /* reset placeholder */

  /* separate question from message received from client and print it */
  for (counter = counter; counter < crypto_box_ZEROBYTES + (crypto_box_NONCEBYTES *2) + INTERNAL_MESSAGE_LENGTH; counter++)
    question.bytes[place++] = client_question_decrypted[counter];

  (void) printf("Question sent by client and received by server in bytes:\n");
  display_bytes(question.bytes, INTERNAL_MESSAGE_LENGTH);

  (void) printf("Question received in plaintext: \n");
  (void) printf("%s\n\n", question.native);

  /* initialize answer  */
  answer.native = "Not much.";

  /* start generating message that contains answer to question sent by client */
  /* add zeroes to beginning of message to be encrypted */
  for (counter = 0; counter < crypto_box_ZEROBYTES; counter++)
    server_answer[counter] = 0;

  place = 0; /* reset placeholder */

  /* add nonce 3 to message */
  for (counter = counter; counter < crypto_box_ZEROBYTES + crypto_box_NONCEBYTES; counter++)
    server_answer[counter] = nonce_n3[place++];

  place = 0; /* reset placeholder */

  /* add question's answer to message and print it */
  for (counter = counter; counter < crypto_box_ZEROBYTES + crypto_box_NONCEBYTES + INTERNAL_MESSAGE_LENGTH; counter++)
    server_answer[counter] = answer.bytes[place++];  

  (void) printf("Message containing answer to be sent from server to client: \n");
  display_bytes(server_answer, crypto_box_ZEROBYTES + crypto_box_NONCEBYTES + INTERNAL_MESSAGE_LENGTH);

  /* encrypt and print message */
  result = crypto_box(encrypted_server_answer, server_answer, crypto_box_ZEROBYTES + crypto_box_NONCEBYTES + INTERNAL_MESSAGE_LENGTH, nonce_n3, pk_from_client, server_sk);
  assert(result == 0);

  (void) printf("Encrypted message to be sent from server to client: \n");
  display_bytes(encrypted_server_answer, crypto_box_ZEROBYTES + crypto_box_NONCEBYTES + INTERNAL_MESSAGE_LENGTH);
}
